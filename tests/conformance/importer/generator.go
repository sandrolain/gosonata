package importer

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

// Generator genera file di test Go dai test cases importati.
type Generator struct {
	outputDir string
	tmpl      *template.Template
}

// NewGenerator crea un nuovo generator.
func NewGenerator(outputDir string) (*Generator, error) {
	if outputDir == "" {
		outputDir = "tests/conformance/imported"
	}

	// Create output directory if needed
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("test").Funcs(template.FuncMap{
		"toCamelCase": toCamelCase,
		"toGoLiteral": toGoLiteral,
		"quote":       quote,
	}).Parse(testTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	return &Generator{
		outputDir: outputDir,
		tmpl:      tmpl,
	}, nil
}

// GenerateGroup genera un file di test per un gruppo.
func (g *Generator) GenerateGroup(info *GroupInfo) (string, error) {
	// Prepare data for template
	data := map[string]interface{}{
		"GroupName":      info.Name,
		"GroupNameCamel": toCamelCase(info.Name),
		"TestCount":      info.TestCount,
		"TestCases":      info.TestCases,
	}

	// Execute template
	var buf bytes.Buffer
	if err := g.tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	// Format code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, return unformatted (for debugging)
		fmt.Printf("Warning: failed to format generated code: %v\n", err)
		formatted = buf.Bytes()
	}

	// Write to file
	filename := strings.ReplaceAll(info.Name, "-", "_") + "_test.go"
	outputPath := filepath.Join(g.outputDir, filename)

	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return "", fmt.Errorf("failed to write file: %w", err)
	}

	return outputPath, nil
}

// toCamelCase converte kebab-case in CamelCase.
func toCamelCase(s string) string {
	parts := strings.Split(s, "-")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

// toGoLiteral converte un valore in literal Go.
func toGoLiteral(v interface{}) string {
	return toGoLiteralRecursive(v)
}

// toGoLiteralRecursive genera ricorsivamente la sintassi Go corretta
func toGoLiteralRecursive(v interface{}) string {
	if v == nil {
		return "nil"
	}

	switch val := v.(type) {
	case bool:
		return fmt.Sprintf("%t", val)

	case float64, float32:
		return fmt.Sprintf("%v", val)

	case int, int8, int16, int32, int64:
		return fmt.Sprintf("%d", val)

	case uint, uint8, uint16, uint32, uint64:
		return fmt.Sprintf("%d", val)

	case string:
		// Escape backticks in string
		escaped := strings.ReplaceAll(val, "`", "`+\"`\"+`")
		return "`" + escaped + "`"

	case []interface{}:
		if len(val) == 0 {
			return "[]interface{}{}"
		}
		var parts []string
		for _, item := range val {
			parts = append(parts, toGoLiteralRecursive(item))
		}
		return "[]interface{}{" + strings.Join(parts, ", ") + "}"

	case map[string]interface{}:
		if len(val) == 0 {
			return "map[string]interface{}{}"
		}
		var parts []string
		// Sort keys for deterministic output
		keys := make([]string, 0, len(val))
		for k := range val {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, k := range keys {
			keyLit := "`" + strings.ReplaceAll(k, "`", "`+\"`\"+`") + "`"
			valLit := toGoLiteralRecursive(val[k])
			parts = append(parts, keyLit+": "+valLit)
		}
		return "map[string]interface{}{" + strings.Join(parts, ", ") + "}"

	default:
		// Fallback: try JSON marshaling and manual conversion
		data, err := json.Marshal(v)
		if err != nil {
			return "nil"
		}

		// Parse back to get proper types
		var parsed interface{}
		if err := json.Unmarshal(data, &parsed); err != nil {
			return "nil"
		}

		return toGoLiteralRecursive(parsed)
	}
}

// quote wraps string in backticks, escaping existing backticks.
func quote(s string) string {
	// Replace backticks with escaped version in raw string
	s = strings.ReplaceAll(s, "`", "`+\"`\"+`")
	return "`" + s + "`"
}

const testTemplate = `// Code generated by importer. DO NOT EDIT.
// Source: thirdy/jsonata/test/test-suite/groups/{{.GroupName}}

package imported_test

import (
	"context"
	"testing"

	"github.com/sandrolain/gosonata/pkg/evaluator"
	"github.com/sandrolain/gosonata/pkg/parser"
)

// Test{{.GroupNameCamel}} runs {{.TestCount}} test cases from the official JSONata test suite.
// Group: {{.GroupName}}
func Test{{.GroupNameCamel}}(t *testing.T) {
	testCases := []struct {
		name        string
		query       string
		data        interface{}
		bindings    map[string]interface{}
		expected    interface{}
		shouldError bool
		errorCode   string
	}{
		{{range .TestCases}}
		{
			name:     "case{{printf "%03d" .CaseNumber}}",
			query:    {{quote .Expression}},
			data:     {{toGoLiteral .InputData}},
			{{if .Bindings}}bindings: {{toGoLiteral .Bindings}},{{end}}
			{{if .ShouldError}}shouldError: true,
			errorCode: "{{.ErrorCode}}",{{else}}expected: {{toGoLiteral .Expected}},{{end}}
		},
		{{end}}
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Parse expression
			expr, err := parser.Parse(tc.query)
			if err != nil {
				if tc.shouldError {
					// Expected error during parsing
					return
				}
				t.Fatalf("Parse error: %v", err)
			}

			// Evaluate
			ev := evaluator.New()
			var result interface{}

			if tc.bindings != nil {
				result, err = ev.EvalWithBindings(context.Background(), expr, tc.data, tc.bindings)
			} else {
				result, err = ev.Eval(context.Background(), expr, tc.data)
			}

			// Check error expectation
			if tc.shouldError {
				if err == nil {
					t.Errorf("Expected error but got result: %v", result)
				}
				// TODO: Check error code when error types are implemented
				return
			}

			if err != nil {
				t.Fatalf("Eval error: %v", err)
			}

			// Compare results (basic comparison for now)
			// TODO: Implement proper deep comparison with JSONata semantics
			if !compareResults(result, tc.expected) {
				t.Errorf("Result mismatch\nGot:      %v\nExpected: %v", result, tc.expected)
			}
		})
	}
}
`
